#-
# Bulk delete Assets using CSV generated by listOlderAssets.py
#

import argparse, csv
from lxml import objectify

import qualysapi 

#-
# Initialize variables
#
DATA_FILE = "bulk_test.csv"
args = []

def build_dict_from_file(input_file):
   with open(input_file, newline='') as csvfile:
      reader = csv.DictReader(csvfile)
   return reader


def delete_row(row_ip):
   # Because args is a global variable, we can use it here without having to 
   # define it within the function or pass it as an argument.
   # We could NOT use `reader` here, because as far as this function knows
   # we haven't defined it yet!
   global args
   if args.get("v", None) is not None:
      confirmation = input(f"Deleting IP {row_ip}. Do you want to proceed? (Y/n)")
      if confirmation.lower() == "n":
         print("Not deleting that IP!")
         # Python returns None if you just use `return` by itself or don't 
         # return anything.
         return
   # f-strings (f"whatever") allow value substitution by including the value
   # inside curly braces. But you have to remember that if you're using a
   # value name that's got quotation marks in it, the quotation marks have
   # to be the other kind from the ones that wrap the string! If the f-string
   # is wrapped in double quotes, your key name or whatever needs to be in
   # single quotes, or vice versa. Below is good!
   print(f"Submitting purge request for {row_ip}.")
      

# Separate out the row deletion into its own function. That way you don't 
# HAVE to purge all the rows at once if you don't want to.
def delete_all_rows(reader):
   for row in reader:
      delete_row(row["IP"])


#-
# Qualys API call to purge the IP list
#
def purge_ip_list(reader):
   ips_to_purge = ",".join([row["IP"] for row in reader])
#	try:
#		a = qualysapi.connect('config.ini')
#		assets = a.request('/api/2.0/fo/asset/host/',{
#         'action':'purge',
#         'data_scope':'pc,vm',
#			'ips':row_ip,
#			},verify=False)  # Prevent 'Self-Signed Certificate in Chain' from blocking activity
#	except AttributeError:
#		print("error", "Can't find the data")


def main():
   # Because we're going to be writing to this global variable (see how it's
   # defined up top?) we want to make sure Python knows that it's global,
   # and not just a local variable inside main() that happens to have
   # the same name. I'm using a global variable as a demonstration of 
   # variable scoping.
   global args
   parser = argparse.ArgumentParser()
   parser.add_argument("-v", "--verify", action="store_true", help="Verify each deletion before processing it")
   parser.add_argument("-s", "--delete-single-row", action="store", help="Only delete this specific IP")
   args = parser.parse_args()
   # Fun new tool: the walrus operator! It looks like this: :=
   # It tells Python "assign this variable and then return the value of 
   # the variable to the enclosing expression."
   if single_ip := args.get("s", None) is not None:
      delete_row(single_ip)
   else:
      csv_reader = build_dict_from_file(DATA_FILE)
      delete_all_rows(csv_reader)

if __name__ == "__main__":
   main()